\section{Описание}
Требуется написать реализацию алгоритма поразрядной сортировки. Идея её заключаются в том, что элементы сортируются по разрядам, начиная с первого. Проходя по разрядам элементов (сначала по первому разряду всех элементов, затем по второму и т.д.), мы сортируем цифры элементов текущего разряда, используя сортировку подсчётом. Получив массив, в котором число $x$ на позиции $i$ определяет количество элементов, у которых на текущем разряде стоит цифра, большая или равная $i$, мы расставляем наши элементы в новый массив согласно правилам сортировки подсчётом. Полученный новый массив \enquote{свайпаем} с нашим старым массивом и проходимся по алгоритму заново, пока все разряды каждого элемента не будут пройдены.

\pagebreak

\section{Исходный код}

Элементы я решил хранить в массиве пар $elems$, у которых на первой позиции находится статический массив $char'$ов с размером 31 (с запасом) для ключа, а на второй позиции $unsigned$ $long$ $long$, который без труда сможет поместить в себя  позицию значения элемента. Ключ сначала вводим в строку, определяем её размер и с помощью этого загоняем наш ключ в массив, начиная с конца массива. Для удобства, в первую позицию массива запишем размер ключа элемента. Также при вводе определяем максимальный размер ключа в переменной $max$\_$num$. После этого подготавливаем всё для самой сортировки: массив $tmp$, который будет хранить количество элементов с конкретной цифрой на текущем разряде, переменна $cnt$, в которую мы будем записывать цифру ключа элемента на текущем разряде, и массив $elems1$, в который мы будем расставлять элементы на соответствующие позиции и затем \enquote{свайпать} с начальным массивом. Массив $tmp$ изначально обнуляем с помощью функции $PutZeroes$.  Проходимся по позициям каждого ключа, начиная с первого разряда и заканчивая разрядом, соответствующим максимальному размеру ключа $max$\_$num$. Заполняем массив $tmp$, если вдруг наш ключ на данном разряде уже закончился, или $cnt$ меньше нуля при переводе из $char$ в $int$ (в случаях \enquote{-} и \enquote{+}), берём $cnt$ как ноль. Складываем постфиксно все элементы. Теперь в массиве $tmp$ число $x$ на позиции $i$ определяет количество элементов, у которых на текущем разряде стоит цифра, большая или равная $i$. Теперь снова проходимся по массиву $elems$, и расставляем наши элементы с помощью массива $tmp$ и переменной $cnt$ в массив $elems1$ на нужную позицию. \enquote{Свайпаем} массивы, проставляем в $tmp$ нули и начинаем итерацию заново. В конце выводим элементы изменённого масиива $elems$.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <math.h>
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
#include <set>
#include <list>

using namespace std;

void PutZeroes(int* a, int n){
    for(int i = 0 ; i < n ; i++){
        a[i] = 0;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    int size = 31;
    pair<char[31], unsigned long long> Pair;
    vector<pair<char[31], unsigned long long>> elems;
    string key;
    auto max_num = key.size();
    while(cin >> key >> Pair.second){
        for(int i = size - key.size() ; i < size ; i++){
            Pair.first[i] = key[key.size() - (size - i)];
        }
        Pair.first[0] = key.size();
        max_num = max(key.size(), max_num);
        elems.push_back(Pair);
    }
    int cnt;
    vector<pair<char[31], unsigned long long>> elems1(elems.size());
    int tmp[10];
    PutZeroes(tmp, 10);
    for(int i = 30 ; i > 30 - max_num ; i--){
        for(int j = 0 ; j < elems.size() ; j++){
            cnt = elems[j].first[i] - '0';
            if(cnt < 0 || elems[j].first[0] < (31 - i)){
               cnt = 0;
            }
            tmp[cnt]++;
        }
        for(int j = 1 ; j < 10 ; j++){
            tmp[j] = tmp[j] + tmp[j - 1];
        }
        for(int j = elems.size() - 1 ; j > -1 ; j--){
            cnt = elems[j].first[i] - '0';
            if(cnt < 0 || elems[j].first[0] < (31 - i)){
               cnt = 0;
            }
            elems1[tmp[cnt] - 1].first[0] = elems[j].first[0];
            for(int k = 31 - elems[j].first[0] ; k < 31 ; k++){
                elems1[tmp[cnt] - 1].first[k] = elems[j].first[k];
            }
            elems1[tmp[cnt] - 1].second = elems[j].second;
            tmp[cnt]--;
        }
        swap(elems, elems1);
        PutZeroes(tmp, 10);
    }
    for(int i = 0 ; i < elems.size() ; i++){
        for(int j = 31 - elems[i].first[0] ; j < 31 ; j++){
            cout << elems[i].first[j];
        }
        cout << '\t' << elems[i].second << '\n';
    }
}
	
\end{lstlisting}

\section{Консоль}
\begin{alltt}
root@DESKTOP-5HM2HTK:~# g++ -pedantic lab1.cpp
root@DESKTOP-5HM2HTK:~# cat test1
+7-495-1123212  13207862122685464576
+375-123-1234567        7670388314707853312
+7-495-1123212  4588010303972900864
+375-123-1234567        12992997081104908288
root@DESKTOP-5HM2HTK:~# ./a.out <test1
+7-495-1123212  13207862122685464576
+7-495-1123212  4588010303972900864
+375-123-1234567        7670388314707853312
+375-123-1234567        12992997081104908288
\end{alltt}
\pagebreak

